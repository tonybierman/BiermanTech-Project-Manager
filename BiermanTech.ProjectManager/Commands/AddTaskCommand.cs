using BiermanTech.ProjectManager.Models;
using BiermanTech.ProjectManager.Data;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;

namespace BiermanTech.ProjectManager.Commands;

public class AddTaskCommand : ICommand
{
    private readonly TaskItem _task;
    private readonly ProjectDbContext _context;
    private readonly int? _parentTaskId;
    private TaskItem _parentTask;

    public AddTaskCommand(TaskItem task, ProjectDbContext context, int? parentTaskId = null)
    {
        _task = task ?? throw new ArgumentNullException(nameof(task));
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _parentTaskId = parentTaskId;
    }

    public void Execute()
    {
        // Set ParentId if applicable (EF will handle relationships)
        if (_parentTaskId.HasValue)
        {
            _parentTask = _context.Tasks
                .Include(t => t.Children)
                .FirstOrDefault(t => t.Id == _parentTaskId.Value);
            if (_parentTask != null)
            {
                _task.ParentId = _parentTaskId.Value;
                _parentTask.Children.Add(_task); // EF will persist this relationship
            }
            else
            {
                throw new InvalidOperationException($"Parent task with ID {_parentTaskId.Value} not found.");
            }
        }

        // Add task to context (ID will be auto-generated by SQLite)
        _context.Tasks.Add(_task);

        // Add dependencies if any (from _task.DependsOnIds)
        if (_task.DependsOnIds != null && _task.DependsOnIds.Any())
        {
            foreach (var dependsOnId in _task.DependsOnIds)
            {
                if (_context.Tasks.Any(t => t.Id == dependsOnId))
                {
                    _context.TaskDependencies.Add(new TaskDependency
                    {
                        TaskId = _task.Id, // Will be set after SaveChanges
                        DependsOnId = dependsOnId
                    });
                }
            }
        }

        // Save changes to persist task and relationships
        _context.SaveChanges();

        // If DependsOnIds were set, update TaskDependencies with the new TaskId
        if (_task.DependsOnIds != null && _task.DependsOnIds.Any())
        {
            var addedTask = _context.Tasks
                .Include(t => t.TaskDependencies)
                .First(t => t.Id == _task.Id);
            foreach (var dependency in addedTask.TaskDependencies)
            {
                dependency.TaskId = addedTask.Id;
            }
            _context.SaveChanges();
        }
    }

    public void Undo()
    {
        var taskToRemove = _context.Tasks
            .Include(t => t.TaskDependencies)
            .FirstOrDefault(t => t.Id == _task.Id);
        if (taskToRemove == null) return;

        // Remove dependencies
        var dependencies = taskToRemove.TaskDependencies.ToList();
        foreach (var dependency in dependencies)
        {
            _context.TaskDependencies.Remove(dependency);
        }

        // Remove from parent's Children if applicable
        if (_parentTask != null)
        {
            _parentTask.Children.Remove(taskToRemove);
        }

        // Remove the task
        _context.Tasks.Remove(taskToRemove);

        // Save changes
        _context.SaveChanges();
    }
}